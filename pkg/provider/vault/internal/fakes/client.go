// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/external-secrets/external-secrets/pkg/provider/vault"
)

type VaultClient struct {
	AddHeaderStub        func(string, string)
	addHeaderMutex       sync.RWMutex
	addHeaderArgsForCall []struct {
		arg1 string
		arg2 string
	}
	AuthStub        func() vault.Auth
	authMutex       sync.RWMutex
	authArgsForCall []struct {
	}
	authReturns struct {
		result1 vault.Auth
	}
	authReturnsOnCall map[int]struct {
		result1 vault.Auth
	}
	AuthTokenStub        func() vault.Token
	authTokenMutex       sync.RWMutex
	authTokenArgsForCall []struct {
	}
	authTokenReturns struct {
		result1 vault.Token
	}
	authTokenReturnsOnCall map[int]struct {
		result1 vault.Token
	}
	ClearTokenStub        func()
	clearTokenMutex       sync.RWMutex
	clearTokenArgsForCall []struct {
	}
	LogicalStub        func() vault.Logical
	logicalMutex       sync.RWMutex
	logicalArgsForCall []struct {
	}
	logicalReturns struct {
		result1 vault.Logical
	}
	logicalReturnsOnCall map[int]struct {
		result1 vault.Logical
	}
	SetNamespaceStub        func(string)
	setNamespaceMutex       sync.RWMutex
	setNamespaceArgsForCall []struct {
		arg1 string
	}
	SetTokenStub        func(string)
	setTokenMutex       sync.RWMutex
	setTokenArgsForCall []struct {
		arg1 string
	}
	TokenStub        func() string
	tokenMutex       sync.RWMutex
	tokenArgsForCall []struct {
	}
	tokenReturns struct {
		result1 string
	}
	tokenReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *VaultClient) AddHeader(arg1 string, arg2 string) {
	fake.addHeaderMutex.Lock()
	fake.addHeaderArgsForCall = append(fake.addHeaderArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AddHeaderStub
	fake.recordInvocation("AddHeader", []interface{}{arg1, arg2})
	fake.addHeaderMutex.Unlock()
	if stub != nil {
		fake.AddHeaderStub(arg1, arg2)
	}
}

func (fake *VaultClient) AddHeaderCallCount() int {
	fake.addHeaderMutex.RLock()
	defer fake.addHeaderMutex.RUnlock()
	return len(fake.addHeaderArgsForCall)
}

func (fake *VaultClient) AddHeaderCalls(stub func(string, string)) {
	fake.addHeaderMutex.Lock()
	defer fake.addHeaderMutex.Unlock()
	fake.AddHeaderStub = stub
}

func (fake *VaultClient) AddHeaderArgsForCall(i int) (string, string) {
	fake.addHeaderMutex.RLock()
	defer fake.addHeaderMutex.RUnlock()
	argsForCall := fake.addHeaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *VaultClient) Auth() vault.Auth {
	fake.authMutex.Lock()
	ret, specificReturn := fake.authReturnsOnCall[len(fake.authArgsForCall)]
	fake.authArgsForCall = append(fake.authArgsForCall, struct {
	}{})
	stub := fake.AuthStub
	fakeReturns := fake.authReturns
	fake.recordInvocation("Auth", []interface{}{})
	fake.authMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *VaultClient) AuthCallCount() int {
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	return len(fake.authArgsForCall)
}

func (fake *VaultClient) AuthCalls(stub func() vault.Auth) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = stub
}

func (fake *VaultClient) AuthReturns(result1 vault.Auth) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = nil
	fake.authReturns = struct {
		result1 vault.Auth
	}{result1}
}

func (fake *VaultClient) AuthReturnsOnCall(i int, result1 vault.Auth) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = nil
	if fake.authReturnsOnCall == nil {
		fake.authReturnsOnCall = make(map[int]struct {
			result1 vault.Auth
		})
	}
	fake.authReturnsOnCall[i] = struct {
		result1 vault.Auth
	}{result1}
}

func (fake *VaultClient) AuthToken() vault.Token {
	fake.authTokenMutex.Lock()
	ret, specificReturn := fake.authTokenReturnsOnCall[len(fake.authTokenArgsForCall)]
	fake.authTokenArgsForCall = append(fake.authTokenArgsForCall, struct {
	}{})
	stub := fake.AuthTokenStub
	fakeReturns := fake.authTokenReturns
	fake.recordInvocation("AuthToken", []interface{}{})
	fake.authTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *VaultClient) AuthTokenCallCount() int {
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	return len(fake.authTokenArgsForCall)
}

func (fake *VaultClient) AuthTokenCalls(stub func() vault.Token) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = stub
}

func (fake *VaultClient) AuthTokenReturns(result1 vault.Token) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = nil
	fake.authTokenReturns = struct {
		result1 vault.Token
	}{result1}
}

func (fake *VaultClient) AuthTokenReturnsOnCall(i int, result1 vault.Token) {
	fake.authTokenMutex.Lock()
	defer fake.authTokenMutex.Unlock()
	fake.AuthTokenStub = nil
	if fake.authTokenReturnsOnCall == nil {
		fake.authTokenReturnsOnCall = make(map[int]struct {
			result1 vault.Token
		})
	}
	fake.authTokenReturnsOnCall[i] = struct {
		result1 vault.Token
	}{result1}
}

func (fake *VaultClient) ClearToken() {
	fake.clearTokenMutex.Lock()
	fake.clearTokenArgsForCall = append(fake.clearTokenArgsForCall, struct {
	}{})
	stub := fake.ClearTokenStub
	fake.recordInvocation("ClearToken", []interface{}{})
	fake.clearTokenMutex.Unlock()
	if stub != nil {
		fake.ClearTokenStub()
	}
}

func (fake *VaultClient) ClearTokenCallCount() int {
	fake.clearTokenMutex.RLock()
	defer fake.clearTokenMutex.RUnlock()
	return len(fake.clearTokenArgsForCall)
}

func (fake *VaultClient) ClearTokenCalls(stub func()) {
	fake.clearTokenMutex.Lock()
	defer fake.clearTokenMutex.Unlock()
	fake.ClearTokenStub = stub
}

func (fake *VaultClient) Logical() vault.Logical {
	fake.logicalMutex.Lock()
	ret, specificReturn := fake.logicalReturnsOnCall[len(fake.logicalArgsForCall)]
	fake.logicalArgsForCall = append(fake.logicalArgsForCall, struct {
	}{})
	stub := fake.LogicalStub
	fakeReturns := fake.logicalReturns
	fake.recordInvocation("Logical", []interface{}{})
	fake.logicalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *VaultClient) LogicalCallCount() int {
	fake.logicalMutex.RLock()
	defer fake.logicalMutex.RUnlock()
	return len(fake.logicalArgsForCall)
}

func (fake *VaultClient) LogicalCalls(stub func() vault.Logical) {
	fake.logicalMutex.Lock()
	defer fake.logicalMutex.Unlock()
	fake.LogicalStub = stub
}

func (fake *VaultClient) LogicalReturns(result1 vault.Logical) {
	fake.logicalMutex.Lock()
	defer fake.logicalMutex.Unlock()
	fake.LogicalStub = nil
	fake.logicalReturns = struct {
		result1 vault.Logical
	}{result1}
}

func (fake *VaultClient) LogicalReturnsOnCall(i int, result1 vault.Logical) {
	fake.logicalMutex.Lock()
	defer fake.logicalMutex.Unlock()
	fake.LogicalStub = nil
	if fake.logicalReturnsOnCall == nil {
		fake.logicalReturnsOnCall = make(map[int]struct {
			result1 vault.Logical
		})
	}
	fake.logicalReturnsOnCall[i] = struct {
		result1 vault.Logical
	}{result1}
}

func (fake *VaultClient) SetNamespace(arg1 string) {
	fake.setNamespaceMutex.Lock()
	fake.setNamespaceArgsForCall = append(fake.setNamespaceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNamespaceStub
	fake.recordInvocation("SetNamespace", []interface{}{arg1})
	fake.setNamespaceMutex.Unlock()
	if stub != nil {
		fake.SetNamespaceStub(arg1)
	}
}

func (fake *VaultClient) SetNamespaceCallCount() int {
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	return len(fake.setNamespaceArgsForCall)
}

func (fake *VaultClient) SetNamespaceCalls(stub func(string)) {
	fake.setNamespaceMutex.Lock()
	defer fake.setNamespaceMutex.Unlock()
	fake.SetNamespaceStub = stub
}

func (fake *VaultClient) SetNamespaceArgsForCall(i int) string {
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	argsForCall := fake.setNamespaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *VaultClient) SetToken(arg1 string) {
	fake.setTokenMutex.Lock()
	fake.setTokenArgsForCall = append(fake.setTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetTokenStub
	fake.recordInvocation("SetToken", []interface{}{arg1})
	fake.setTokenMutex.Unlock()
	if stub != nil {
		fake.SetTokenStub(arg1)
	}
}

func (fake *VaultClient) SetTokenCallCount() int {
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	return len(fake.setTokenArgsForCall)
}

func (fake *VaultClient) SetTokenCalls(stub func(string)) {
	fake.setTokenMutex.Lock()
	defer fake.setTokenMutex.Unlock()
	fake.SetTokenStub = stub
}

func (fake *VaultClient) SetTokenArgsForCall(i int) string {
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	argsForCall := fake.setTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *VaultClient) Token() string {
	fake.tokenMutex.Lock()
	ret, specificReturn := fake.tokenReturnsOnCall[len(fake.tokenArgsForCall)]
	fake.tokenArgsForCall = append(fake.tokenArgsForCall, struct {
	}{})
	stub := fake.TokenStub
	fakeReturns := fake.tokenReturns
	fake.recordInvocation("Token", []interface{}{})
	fake.tokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *VaultClient) TokenCallCount() int {
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	return len(fake.tokenArgsForCall)
}

func (fake *VaultClient) TokenCalls(stub func() string) {
	fake.tokenMutex.Lock()
	defer fake.tokenMutex.Unlock()
	fake.TokenStub = stub
}

func (fake *VaultClient) TokenReturns(result1 string) {
	fake.tokenMutex.Lock()
	defer fake.tokenMutex.Unlock()
	fake.TokenStub = nil
	fake.tokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *VaultClient) TokenReturnsOnCall(i int, result1 string) {
	fake.tokenMutex.Lock()
	defer fake.tokenMutex.Unlock()
	fake.TokenStub = nil
	if fake.tokenReturnsOnCall == nil {
		fake.tokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *VaultClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addHeaderMutex.RLock()
	defer fake.addHeaderMutex.RUnlock()
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	fake.authTokenMutex.RLock()
	defer fake.authTokenMutex.RUnlock()
	fake.clearTokenMutex.RLock()
	defer fake.clearTokenMutex.RUnlock()
	fake.logicalMutex.RLock()
	defer fake.logicalMutex.RUnlock()
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *VaultClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ vault.Client = new(VaultClient)
